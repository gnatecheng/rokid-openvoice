// Code generated by protoc-gen-go.
// source: speech.proto
// DO NOT EDIT!

/*
Package rokid_open is a generated protocol buffer package.

It is generated from these files:
	speech.proto

It has these top-level messages:
	AuthRequest
	AuthResponse
	AsrRequest
	AsrHeader
	AsrResponse
	NlpRequest
	NlpHeader
	NlpResponse
	TtsRequest
	TtsHeader
	TtsResponse
	VoiceSpeechRequest
	TextSpeechRequest
	SpeechResponse
	SpeechHeader
*/
package rokid_open

import proto "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"

import (
	context "golang.org/x/net/context"
	grpc "google.golang.org/grpc"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion2 // please upgrade the proto package

type AuthRequest struct {
	Key          string `protobuf:"bytes,1,opt,name=key" json:"key,omitempty"`
	DeviceTypeId string `protobuf:"bytes,2,opt,name=device_type_id,json=deviceTypeId" json:"device_type_id,omitempty"`
	DeviceId     string `protobuf:"bytes,3,opt,name=device_id,json=deviceId" json:"device_id,omitempty"`
	Service      string `protobuf:"bytes,4,opt,name=service" json:"service,omitempty"`
	Version      string `protobuf:"bytes,5,opt,name=version" json:"version,omitempty"`
	Timestamp    string `protobuf:"bytes,6,opt,name=timestamp" json:"timestamp,omitempty"`
	Sign         string `protobuf:"bytes,7,opt,name=sign" json:"sign,omitempty"`
}

func (m *AuthRequest) Reset()                    { *m = AuthRequest{} }
func (m *AuthRequest) String() string            { return proto.CompactTextString(m) }
func (*AuthRequest) ProtoMessage()               {}
func (*AuthRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{0} }

type AuthResponse struct {
	// 0: success; -1: failed
	Result int32 `protobuf:"varint,1,opt,name=result" json:"result,omitempty"`
}

func (m *AuthResponse) Reset()                    { *m = AuthResponse{} }
func (m *AuthResponse) String() string            { return proto.CompactTextString(m) }
func (*AuthResponse) ProtoMessage()               {}
func (*AuthResponse) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{1} }

type AsrRequest struct {
	// Types that are valid to be assigned to RequestContent:
	//	*AsrRequest_Header
	//	*AsrRequest_Voice
	RequestContent isAsrRequest_RequestContent `protobuf_oneof:"request_content"`
}

func (m *AsrRequest) Reset()                    { *m = AsrRequest{} }
func (m *AsrRequest) String() string            { return proto.CompactTextString(m) }
func (*AsrRequest) ProtoMessage()               {}
func (*AsrRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{2} }

type isAsrRequest_RequestContent interface {
	isAsrRequest_RequestContent()
}

type AsrRequest_Header struct {
	Header *AsrHeader `protobuf:"bytes,1,opt,name=header,oneof"`
}
type AsrRequest_Voice struct {
	Voice []byte `protobuf:"bytes,2,opt,name=voice,proto3,oneof"`
}

func (*AsrRequest_Header) isAsrRequest_RequestContent() {}
func (*AsrRequest_Voice) isAsrRequest_RequestContent()  {}

func (m *AsrRequest) GetRequestContent() isAsrRequest_RequestContent {
	if m != nil {
		return m.RequestContent
	}
	return nil
}

func (m *AsrRequest) GetHeader() *AsrHeader {
	if x, ok := m.GetRequestContent().(*AsrRequest_Header); ok {
		return x.Header
	}
	return nil
}

func (m *AsrRequest) GetVoice() []byte {
	if x, ok := m.GetRequestContent().(*AsrRequest_Voice); ok {
		return x.Voice
	}
	return nil
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*AsrRequest) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _AsrRequest_OneofMarshaler, _AsrRequest_OneofUnmarshaler, _AsrRequest_OneofSizer, []interface{}{
		(*AsrRequest_Header)(nil),
		(*AsrRequest_Voice)(nil),
	}
}

func _AsrRequest_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*AsrRequest)
	// request_content
	switch x := m.RequestContent.(type) {
	case *AsrRequest_Header:
		b.EncodeVarint(1<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Header); err != nil {
			return err
		}
	case *AsrRequest_Voice:
		b.EncodeVarint(2<<3 | proto.WireBytes)
		b.EncodeRawBytes(x.Voice)
	case nil:
	default:
		return fmt.Errorf("AsrRequest.RequestContent has unexpected type %T", x)
	}
	return nil
}

func _AsrRequest_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*AsrRequest)
	switch tag {
	case 1: // request_content.header
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(AsrHeader)
		err := b.DecodeMessage(msg)
		m.RequestContent = &AsrRequest_Header{msg}
		return true, err
	case 2: // request_content.voice
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeRawBytes(true)
		m.RequestContent = &AsrRequest_Voice{x}
		return true, err
	default:
		return false, nil
	}
}

func _AsrRequest_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*AsrRequest)
	// request_content
	switch x := m.RequestContent.(type) {
	case *AsrRequest_Header:
		s := proto.Size(x.Header)
		n += proto.SizeVarint(1<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *AsrRequest_Voice:
		n += proto.SizeVarint(2<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(len(x.Voice)))
		n += len(x.Voice)
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

type AsrHeader struct {
	Id    int32  `protobuf:"varint,1,opt,name=id" json:"id,omitempty"`
	Lang  string `protobuf:"bytes,2,opt,name=lang" json:"lang,omitempty"`
	Codec string `protobuf:"bytes,3,opt,name=codec" json:"codec,omitempty"`
	// vt = voice trigger
	Vt string `protobuf:"bytes,4,opt,name=vt" json:"vt,omitempty"`
}

func (m *AsrHeader) Reset()                    { *m = AsrHeader{} }
func (m *AsrHeader) String() string            { return proto.CompactTextString(m) }
func (*AsrHeader) ProtoMessage()               {}
func (*AsrHeader) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{3} }

type AsrResponse struct {
	Asr string `protobuf:"bytes,1,opt,name=asr" json:"asr,omitempty"`
}

func (m *AsrResponse) Reset()                    { *m = AsrResponse{} }
func (m *AsrResponse) String() string            { return proto.CompactTextString(m) }
func (*AsrResponse) ProtoMessage()               {}
func (*AsrResponse) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{4} }

type NlpRequest struct {
	Header *NlpHeader `protobuf:"bytes,1,opt,name=header" json:"header,omitempty"`
	Asr    string     `protobuf:"bytes,2,opt,name=asr" json:"asr,omitempty"`
}

func (m *NlpRequest) Reset()                    { *m = NlpRequest{} }
func (m *NlpRequest) String() string            { return proto.CompactTextString(m) }
func (*NlpRequest) ProtoMessage()               {}
func (*NlpRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{5} }

func (m *NlpRequest) GetHeader() *NlpHeader {
	if m != nil {
		return m.Header
	}
	return nil
}

type NlpHeader struct {
	Id      int32  `protobuf:"varint,1,opt,name=id" json:"id,omitempty"`
	Lang    string `protobuf:"bytes,2,opt,name=lang" json:"lang,omitempty"`
	Cdomain string `protobuf:"bytes,3,opt,name=cdomain" json:"cdomain,omitempty"`
}

func (m *NlpHeader) Reset()                    { *m = NlpHeader{} }
func (m *NlpHeader) String() string            { return proto.CompactTextString(m) }
func (*NlpHeader) ProtoMessage()               {}
func (*NlpHeader) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{6} }

type NlpResponse struct {
	Nlp string `protobuf:"bytes,1,opt,name=nlp" json:"nlp,omitempty"`
}

func (m *NlpResponse) Reset()                    { *m = NlpResponse{} }
func (m *NlpResponse) String() string            { return proto.CompactTextString(m) }
func (*NlpResponse) ProtoMessage()               {}
func (*NlpResponse) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{7} }

type TtsRequest struct {
	Header *TtsHeader `protobuf:"bytes,1,opt,name=header" json:"header,omitempty"`
	Text   string     `protobuf:"bytes,2,opt,name=text" json:"text,omitempty"`
}

func (m *TtsRequest) Reset()                    { *m = TtsRequest{} }
func (m *TtsRequest) String() string            { return proto.CompactTextString(m) }
func (*TtsRequest) ProtoMessage()               {}
func (*TtsRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{8} }

func (m *TtsRequest) GetHeader() *TtsHeader {
	if m != nil {
		return m.Header
	}
	return nil
}

type TtsHeader struct {
	Id        int32  `protobuf:"varint,1,opt,name=id" json:"id,omitempty"`
	Declaimer string `protobuf:"bytes,2,opt,name=declaimer" json:"declaimer,omitempty"`
	Codec     string `protobuf:"bytes,3,opt,name=codec" json:"codec,omitempty"`
}

func (m *TtsHeader) Reset()                    { *m = TtsHeader{} }
func (m *TtsHeader) String() string            { return proto.CompactTextString(m) }
func (*TtsHeader) ProtoMessage()               {}
func (*TtsHeader) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{9} }

type TtsResponse struct {
	Text  string `protobuf:"bytes,1,opt,name=text" json:"text,omitempty"`
	Voice []byte `protobuf:"bytes,2,opt,name=voice,proto3" json:"voice,omitempty"`
}

func (m *TtsResponse) Reset()                    { *m = TtsResponse{} }
func (m *TtsResponse) String() string            { return proto.CompactTextString(m) }
func (*TtsResponse) ProtoMessage()               {}
func (*TtsResponse) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{10} }

type VoiceSpeechRequest struct {
	// Types that are valid to be assigned to RequestContent:
	//	*VoiceSpeechRequest_Header
	//	*VoiceSpeechRequest_Voice
	RequestContent isVoiceSpeechRequest_RequestContent `protobuf_oneof:"request_content"`
}

func (m *VoiceSpeechRequest) Reset()                    { *m = VoiceSpeechRequest{} }
func (m *VoiceSpeechRequest) String() string            { return proto.CompactTextString(m) }
func (*VoiceSpeechRequest) ProtoMessage()               {}
func (*VoiceSpeechRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{11} }

type isVoiceSpeechRequest_RequestContent interface {
	isVoiceSpeechRequest_RequestContent()
}

type VoiceSpeechRequest_Header struct {
	Header *SpeechHeader `protobuf:"bytes,1,opt,name=header,oneof"`
}
type VoiceSpeechRequest_Voice struct {
	Voice []byte `protobuf:"bytes,2,opt,name=voice,proto3,oneof"`
}

func (*VoiceSpeechRequest_Header) isVoiceSpeechRequest_RequestContent() {}
func (*VoiceSpeechRequest_Voice) isVoiceSpeechRequest_RequestContent()  {}

func (m *VoiceSpeechRequest) GetRequestContent() isVoiceSpeechRequest_RequestContent {
	if m != nil {
		return m.RequestContent
	}
	return nil
}

func (m *VoiceSpeechRequest) GetHeader() *SpeechHeader {
	if x, ok := m.GetRequestContent().(*VoiceSpeechRequest_Header); ok {
		return x.Header
	}
	return nil
}

func (m *VoiceSpeechRequest) GetVoice() []byte {
	if x, ok := m.GetRequestContent().(*VoiceSpeechRequest_Voice); ok {
		return x.Voice
	}
	return nil
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*VoiceSpeechRequest) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _VoiceSpeechRequest_OneofMarshaler, _VoiceSpeechRequest_OneofUnmarshaler, _VoiceSpeechRequest_OneofSizer, []interface{}{
		(*VoiceSpeechRequest_Header)(nil),
		(*VoiceSpeechRequest_Voice)(nil),
	}
}

func _VoiceSpeechRequest_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*VoiceSpeechRequest)
	// request_content
	switch x := m.RequestContent.(type) {
	case *VoiceSpeechRequest_Header:
		b.EncodeVarint(1<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Header); err != nil {
			return err
		}
	case *VoiceSpeechRequest_Voice:
		b.EncodeVarint(2<<3 | proto.WireBytes)
		b.EncodeRawBytes(x.Voice)
	case nil:
	default:
		return fmt.Errorf("VoiceSpeechRequest.RequestContent has unexpected type %T", x)
	}
	return nil
}

func _VoiceSpeechRequest_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*VoiceSpeechRequest)
	switch tag {
	case 1: // request_content.header
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(SpeechHeader)
		err := b.DecodeMessage(msg)
		m.RequestContent = &VoiceSpeechRequest_Header{msg}
		return true, err
	case 2: // request_content.voice
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeRawBytes(true)
		m.RequestContent = &VoiceSpeechRequest_Voice{x}
		return true, err
	default:
		return false, nil
	}
}

func _VoiceSpeechRequest_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*VoiceSpeechRequest)
	// request_content
	switch x := m.RequestContent.(type) {
	case *VoiceSpeechRequest_Header:
		s := proto.Size(x.Header)
		n += proto.SizeVarint(1<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *VoiceSpeechRequest_Voice:
		n += proto.SizeVarint(2<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(len(x.Voice)))
		n += len(x.Voice)
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

type TextSpeechRequest struct {
	Header *SpeechHeader `protobuf:"bytes,1,opt,name=header" json:"header,omitempty"`
	Asr    string        `protobuf:"bytes,2,opt,name=asr" json:"asr,omitempty"`
}

func (m *TextSpeechRequest) Reset()                    { *m = TextSpeechRequest{} }
func (m *TextSpeechRequest) String() string            { return proto.CompactTextString(m) }
func (*TextSpeechRequest) ProtoMessage()               {}
func (*TextSpeechRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{12} }

func (m *TextSpeechRequest) GetHeader() *SpeechHeader {
	if m != nil {
		return m.Header
	}
	return nil
}

type SpeechResponse struct {
	Asr    string `protobuf:"bytes,1,opt,name=asr" json:"asr,omitempty"`
	Nlp    string `protobuf:"bytes,2,opt,name=nlp" json:"nlp,omitempty"`
	Action string `protobuf:"bytes,3,opt,name=action" json:"action,omitempty"`
}

func (m *SpeechResponse) Reset()                    { *m = SpeechResponse{} }
func (m *SpeechResponse) String() string            { return proto.CompactTextString(m) }
func (*SpeechResponse) ProtoMessage()               {}
func (*SpeechResponse) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{13} }

type SpeechHeader struct {
	Id int32 `protobuf:"varint,1,opt,name=id" json:"id,omitempty"`
	// zh en
	Lang string `protobuf:"bytes,2,opt,name=lang" json:"lang,omitempty"`
	// pcm opu opu2
	Codec string `protobuf:"bytes,3,opt,name=codec" json:"codec,omitempty"`
	// vt = voice trigger
	Vt string `protobuf:"bytes,4,opt,name=vt" json:"vt,omitempty"`
	// stack of current domains
	Cdomain string `protobuf:"bytes,5,opt,name=cdomain" json:"cdomain,omitempty"`
	// js format
	Device string `protobuf:"bytes,6,opt,name=device" json:"device,omitempty"`
}

func (m *SpeechHeader) Reset()                    { *m = SpeechHeader{} }
func (m *SpeechHeader) String() string            { return proto.CompactTextString(m) }
func (*SpeechHeader) ProtoMessage()               {}
func (*SpeechHeader) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{14} }

func init() {
	proto.RegisterType((*AuthRequest)(nil), "rokid.open.AuthRequest")
	proto.RegisterType((*AuthResponse)(nil), "rokid.open.AuthResponse")
	proto.RegisterType((*AsrRequest)(nil), "rokid.open.AsrRequest")
	proto.RegisterType((*AsrHeader)(nil), "rokid.open.AsrHeader")
	proto.RegisterType((*AsrResponse)(nil), "rokid.open.AsrResponse")
	proto.RegisterType((*NlpRequest)(nil), "rokid.open.NlpRequest")
	proto.RegisterType((*NlpHeader)(nil), "rokid.open.NlpHeader")
	proto.RegisterType((*NlpResponse)(nil), "rokid.open.NlpResponse")
	proto.RegisterType((*TtsRequest)(nil), "rokid.open.TtsRequest")
	proto.RegisterType((*TtsHeader)(nil), "rokid.open.TtsHeader")
	proto.RegisterType((*TtsResponse)(nil), "rokid.open.TtsResponse")
	proto.RegisterType((*VoiceSpeechRequest)(nil), "rokid.open.VoiceSpeechRequest")
	proto.RegisterType((*TextSpeechRequest)(nil), "rokid.open.TextSpeechRequest")
	proto.RegisterType((*SpeechResponse)(nil), "rokid.open.SpeechResponse")
	proto.RegisterType((*SpeechHeader)(nil), "rokid.open.SpeechHeader")
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion3

// Client API for Speech service

type SpeechClient interface {
	Auth(ctx context.Context, in *AuthRequest, opts ...grpc.CallOption) (*AuthResponse, error)
	Asr(ctx context.Context, opts ...grpc.CallOption) (Speech_AsrClient, error)
	Nlp(ctx context.Context, in *NlpRequest, opts ...grpc.CallOption) (*NlpResponse, error)
	Tts(ctx context.Context, in *TtsRequest, opts ...grpc.CallOption) (Speech_TtsClient, error)
	Speechv(ctx context.Context, opts ...grpc.CallOption) (Speech_SpeechvClient, error)
	Speecht(ctx context.Context, in *TextSpeechRequest, opts ...grpc.CallOption) (*SpeechResponse, error)
}

type speechClient struct {
	cc *grpc.ClientConn
}

func NewSpeechClient(cc *grpc.ClientConn) SpeechClient {
	return &speechClient{cc}
}

func (c *speechClient) Auth(ctx context.Context, in *AuthRequest, opts ...grpc.CallOption) (*AuthResponse, error) {
	out := new(AuthResponse)
	err := grpc.Invoke(ctx, "/rokid.open.Speech/auth", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *speechClient) Asr(ctx context.Context, opts ...grpc.CallOption) (Speech_AsrClient, error) {
	stream, err := grpc.NewClientStream(ctx, &_Speech_serviceDesc.Streams[0], c.cc, "/rokid.open.Speech/asr", opts...)
	if err != nil {
		return nil, err
	}
	x := &speechAsrClient{stream}
	return x, nil
}

type Speech_AsrClient interface {
	Send(*AsrRequest) error
	Recv() (*AsrResponse, error)
	grpc.ClientStream
}

type speechAsrClient struct {
	grpc.ClientStream
}

func (x *speechAsrClient) Send(m *AsrRequest) error {
	return x.ClientStream.SendMsg(m)
}

func (x *speechAsrClient) Recv() (*AsrResponse, error) {
	m := new(AsrResponse)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *speechClient) Nlp(ctx context.Context, in *NlpRequest, opts ...grpc.CallOption) (*NlpResponse, error) {
	out := new(NlpResponse)
	err := grpc.Invoke(ctx, "/rokid.open.Speech/nlp", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *speechClient) Tts(ctx context.Context, in *TtsRequest, opts ...grpc.CallOption) (Speech_TtsClient, error) {
	stream, err := grpc.NewClientStream(ctx, &_Speech_serviceDesc.Streams[1], c.cc, "/rokid.open.Speech/tts", opts...)
	if err != nil {
		return nil, err
	}
	x := &speechTtsClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type Speech_TtsClient interface {
	Recv() (*TtsResponse, error)
	grpc.ClientStream
}

type speechTtsClient struct {
	grpc.ClientStream
}

func (x *speechTtsClient) Recv() (*TtsResponse, error) {
	m := new(TtsResponse)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *speechClient) Speechv(ctx context.Context, opts ...grpc.CallOption) (Speech_SpeechvClient, error) {
	stream, err := grpc.NewClientStream(ctx, &_Speech_serviceDesc.Streams[2], c.cc, "/rokid.open.Speech/speechv", opts...)
	if err != nil {
		return nil, err
	}
	x := &speechSpeechvClient{stream}
	return x, nil
}

type Speech_SpeechvClient interface {
	Send(*VoiceSpeechRequest) error
	Recv() (*SpeechResponse, error)
	grpc.ClientStream
}

type speechSpeechvClient struct {
	grpc.ClientStream
}

func (x *speechSpeechvClient) Send(m *VoiceSpeechRequest) error {
	return x.ClientStream.SendMsg(m)
}

func (x *speechSpeechvClient) Recv() (*SpeechResponse, error) {
	m := new(SpeechResponse)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *speechClient) Speecht(ctx context.Context, in *TextSpeechRequest, opts ...grpc.CallOption) (*SpeechResponse, error) {
	out := new(SpeechResponse)
	err := grpc.Invoke(ctx, "/rokid.open.Speech/speecht", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// Server API for Speech service

type SpeechServer interface {
	Auth(context.Context, *AuthRequest) (*AuthResponse, error)
	Asr(Speech_AsrServer) error
	Nlp(context.Context, *NlpRequest) (*NlpResponse, error)
	Tts(*TtsRequest, Speech_TtsServer) error
	Speechv(Speech_SpeechvServer) error
	Speecht(context.Context, *TextSpeechRequest) (*SpeechResponse, error)
}

func RegisterSpeechServer(s *grpc.Server, srv SpeechServer) {
	s.RegisterService(&_Speech_serviceDesc, srv)
}

func _Speech_Auth_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AuthRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SpeechServer).Auth(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/rokid.open.Speech/Auth",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SpeechServer).Auth(ctx, req.(*AuthRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Speech_Asr_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(SpeechServer).Asr(&speechAsrServer{stream})
}

type Speech_AsrServer interface {
	Send(*AsrResponse) error
	Recv() (*AsrRequest, error)
	grpc.ServerStream
}

type speechAsrServer struct {
	grpc.ServerStream
}

func (x *speechAsrServer) Send(m *AsrResponse) error {
	return x.ServerStream.SendMsg(m)
}

func (x *speechAsrServer) Recv() (*AsrRequest, error) {
	m := new(AsrRequest)
	if err := x.ServerStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func _Speech_Nlp_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(NlpRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SpeechServer).Nlp(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/rokid.open.Speech/Nlp",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SpeechServer).Nlp(ctx, req.(*NlpRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Speech_Tts_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(TtsRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(SpeechServer).Tts(m, &speechTtsServer{stream})
}

type Speech_TtsServer interface {
	Send(*TtsResponse) error
	grpc.ServerStream
}

type speechTtsServer struct {
	grpc.ServerStream
}

func (x *speechTtsServer) Send(m *TtsResponse) error {
	return x.ServerStream.SendMsg(m)
}

func _Speech_Speechv_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(SpeechServer).Speechv(&speechSpeechvServer{stream})
}

type Speech_SpeechvServer interface {
	Send(*SpeechResponse) error
	Recv() (*VoiceSpeechRequest, error)
	grpc.ServerStream
}

type speechSpeechvServer struct {
	grpc.ServerStream
}

func (x *speechSpeechvServer) Send(m *SpeechResponse) error {
	return x.ServerStream.SendMsg(m)
}

func (x *speechSpeechvServer) Recv() (*VoiceSpeechRequest, error) {
	m := new(VoiceSpeechRequest)
	if err := x.ServerStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func _Speech_Speecht_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(TextSpeechRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SpeechServer).Speecht(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/rokid.open.Speech/Speecht",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SpeechServer).Speecht(ctx, req.(*TextSpeechRequest))
	}
	return interceptor(ctx, in, info, handler)
}

var _Speech_serviceDesc = grpc.ServiceDesc{
	ServiceName: "rokid.open.Speech",
	HandlerType: (*SpeechServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "auth",
			Handler:    _Speech_Auth_Handler,
		},
		{
			MethodName: "nlp",
			Handler:    _Speech_Nlp_Handler,
		},
		{
			MethodName: "speecht",
			Handler:    _Speech_Speecht_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "asr",
			Handler:       _Speech_Asr_Handler,
			ServerStreams: true,
			ClientStreams: true,
		},
		{
			StreamName:    "tts",
			Handler:       _Speech_Tts_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "speechv",
			Handler:       _Speech_Speechv_Handler,
			ServerStreams: true,
			ClientStreams: true,
		},
	},
	Metadata: fileDescriptor0,
}

func init() { proto.RegisterFile("speech.proto", fileDescriptor0) }

var fileDescriptor0 = []byte{
	// 636 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x09, 0x6e, 0x88, 0x02, 0xff, 0xac, 0x55, 0x4b, 0x6f, 0xd3, 0x4e,
	0x10, 0x8f, 0xf3, 0xea, 0xdf, 0x93, 0x28, 0x7f, 0xba, 0x82, 0xd6, 0x0a, 0xe5, 0xa1, 0x15, 0x42,
	0xbd, 0x10, 0xaa, 0x70, 0x00, 0x01, 0x97, 0x72, 0x40, 0xad, 0x78, 0x49, 0x21, 0xc0, 0x31, 0x32,
	0xf6, 0xaa, 0xb1, 0x9a, 0xd8, 0xc6, 0xbb, 0x89, 0xe8, 0x57, 0xe0, 0xc0, 0xe7, 0xe2, 0x63, 0x31,
	0xfb, 0x8a, 0x5f, 0x25, 0x8a, 0x04, 0xb7, 0x19, 0xcf, 0xec, 0xcc, 0xef, 0x37, 0x2f, 0x43, 0x9f,
	0xa7, 0x8c, 0x05, 0xf3, 0x51, 0x9a, 0x25, 0x22, 0x21, 0x90, 0x25, 0x97, 0x51, 0x38, 0x4a, 0x52,
	0x16, 0xd3, 0x5f, 0x0e, 0xf4, 0x4e, 0x57, 0x62, 0x3e, 0x61, 0xdf, 0x56, 0x8c, 0x0b, 0x72, 0x03,
	0x5a, 0x97, 0xec, 0xca, 0x73, 0xee, 0x3b, 0xc7, 0xee, 0x44, 0x8a, 0xe4, 0x01, 0x0c, 0x42, 0xb6,
	0x8e, 0x02, 0x36, 0x13, 0x57, 0x29, 0x9b, 0x45, 0xa1, 0xd7, 0x54, 0xc6, 0xbe, 0xfe, 0x3a, 0xc5,
	0x8f, 0xe7, 0x21, 0xb9, 0x0d, 0xae, 0xf1, 0x42, 0x87, 0x96, 0x72, 0xf8, 0x4f, 0x7f, 0x40, 0xa3,
	0x07, 0x7b, 0x9c, 0x65, 0x52, 0xf1, 0xda, 0xca, 0x64, 0x55, 0x69, 0x59, 0xb3, 0x8c, 0x47, 0x49,
	0xec, 0x75, 0xb4, 0xc5, 0xa8, 0xe4, 0x08, 0x5c, 0x11, 0x2d, 0x11, 0x92, 0xbf, 0x4c, 0xbd, 0xae,
	0xb2, 0xe5, 0x1f, 0x08, 0x81, 0x36, 0x8f, 0x2e, 0x62, 0x6f, 0x4f, 0x19, 0x94, 0x4c, 0x1f, 0x42,
	0x5f, 0x33, 0xe1, 0x69, 0x12, 0x73, 0x46, 0x0e, 0xa0, 0x9b, 0x31, 0xbe, 0x5a, 0x08, 0xc5, 0xa6,
	0x33, 0x31, 0x1a, 0x9d, 0x03, 0x9c, 0xf2, 0xcc, 0x12, 0x7e, 0x0c, 0xdd, 0x39, 0xf3, 0x43, 0x96,
	0x29, 0xaf, 0xde, 0xf8, 0xd6, 0x28, 0xaf, 0xce, 0x08, 0xfd, 0xce, 0x94, 0xf1, 0xac, 0x31, 0x31,
	0x6e, 0x18, 0xb6, 0xb3, 0x4e, 0x24, 0x15, 0x59, 0x86, 0x3e, 0x1a, 0xb4, 0xfa, 0x6a, 0x1f, 0xfe,
	0xcf, 0x74, 0xcc, 0x59, 0x90, 0xc4, 0x82, 0xc5, 0x82, 0x7e, 0x02, 0x77, 0x13, 0x81, 0x0c, 0xa0,
	0x89, 0xa5, 0xd1, 0x50, 0x50, 0x92, 0x14, 0x16, 0x7e, 0x7c, 0x61, 0xaa, 0xa9, 0x64, 0x72, 0x13,
	0x3a, 0x41, 0x12, 0xb2, 0xc0, 0x54, 0x50, 0x2b, 0xf2, 0xe5, 0x5a, 0x98, 0xca, 0xa1, 0x44, 0xef,
	0x61, 0xcb, 0x24, 0x01, 0xc3, 0x13, 0x5b, 0xe6, 0xf3, 0xcc, 0xb6, 0x0c, 0x45, 0xfa, 0x0e, 0xe0,
	0xfd, 0x22, 0xb5, 0x0c, 0x1f, 0x6d, 0x63, 0x88, 0x7e, 0x1a, 0xdf, 0x86, 0x9f, 0x09, 0xd7, 0xcc,
	0xc3, 0x9d, 0x83, 0xbb, 0x71, 0xdb, 0x89, 0x06, 0x76, 0x35, 0x08, 0x93, 0xa5, 0x1f, 0xc5, 0x86,
	0x88, 0x55, 0x25, 0x74, 0x85, 0x2c, 0x87, 0x1e, 0x2f, 0x52, 0x0b, 0x1d, 0x45, 0xfa, 0x01, 0x60,
	0x2a, 0xf8, 0x4e, 0xd0, 0xd1, 0xaf, 0x02, 0x1d, 0xb1, 0x08, 0xf6, 0x5d, 0x58, 0x2c, 0x52, 0xc6,
	0x80, 0xee, 0xc6, 0xb1, 0x06, 0xfe, 0x48, 0x4e, 0x6d, 0xb0, 0xf0, 0x71, 0xae, 0x2c, 0xe3, 0xfc,
	0xc3, 0xf5, 0xdd, 0xa0, 0x4f, 0xa1, 0xa7, 0x10, 0x1a, 0x0a, 0x36, 0xa7, 0x93, 0xe7, 0x94, 0x0f,
	0x0b, 0x23, 0x62, 0x06, 0x84, 0x72, 0x20, 0x9f, 0xa5, 0xf0, 0x51, 0xed, 0xa2, 0xa5, 0x38, 0xae,
	0x50, 0xf4, 0x8a, 0x14, 0xb5, 0xeb, 0xdf, 0x8c, 0xe0, 0x17, 0xd8, 0x9f, 0x22, 0xa4, 0x72, 0xce,
	0x93, 0x5d, 0x73, 0x6e, 0x19, 0x8a, 0xb7, 0x30, 0xb0, 0x41, 0xff, 0x34, 0x87, 0xb6, 0xbd, 0xcd,
	0x4d, 0x7b, 0xe5, 0x4e, 0xfa, 0x81, 0x90, 0xeb, 0xae, 0x6b, 0x6a, 0x34, 0xfa, 0xc3, 0x81, 0x7e,
	0x31, 0xf1, 0xbf, 0xdb, 0x96, 0xe2, 0x30, 0x76, 0x4a, 0xc3, 0x28, 0xc1, 0xe8, 0x13, 0x65, 0xee,
	0x8b, 0xd1, 0xc6, 0x3f, 0x5b, 0xd0, 0xd5, 0x60, 0xc8, 0x0b, 0x68, 0xfb, 0x78, 0x53, 0xc8, 0x61,
	0xe9, 0x2a, 0xe4, 0xf7, 0x72, 0xe8, 0xd5, 0x0d, 0xba, 0x1c, 0xb4, 0x41, 0x5e, 0xaa, 0x82, 0x90,
	0x83, 0xca, 0x45, 0xb1, 0x4f, 0x0f, 0x6b, 0xdf, 0xed, 0xcb, 0x63, 0xe7, 0xc4, 0x21, 0xcf, 0x40,
	0x57, 0xac, 0xb2, 0xad, 0xd7, 0xbe, 0x2e, 0xec, 0x14, 0xe6, 0x7d, 0x0e, 0x2d, 0x21, 0x78, 0xf9,
	0x65, 0xbe, 0x54, 0xe5, 0x97, 0x85, 0x51, 0xa6, 0x0d, 0xcc, 0xfa, 0x06, 0x4f, 0xb5, 0xa2, 0xbe,
	0x26, 0x77, 0x8b, 0x7e, 0xf5, 0xc9, 0x1d, 0x0e, 0xeb, 0x53, 0x53, 0xa1, 0xf0, 0xda, 0x06, 0x13,
	0xe4, 0x4e, 0x29, 0x69, 0x75, 0x22, 0xb7, 0xc7, 0xfa, 0xda, 0x55, 0xff, 0xad, 0x27, 0xbf, 0x03,
	0x00, 0x00, 0xff, 0xff, 0x1b, 0x5b, 0xb2, 0x27, 0xc7, 0x06, 0x00, 0x00,
}
